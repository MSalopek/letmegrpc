// Code generated by protoc-gen-gogo.
// source: grpc.proto
// DO NOT EDIT!

/*
Package grpc is a generated protocol buffer package.

It is generated from these files:
	grpc.proto

It has these top-level messages:
	MyRequest
	MyResponse
	MyMsg
	MyMsg2
*/
package grpc

import net_http "net/http"
import encoding_json "encoding/json"
import io "io"
import net "net"
import golang_org_x_net_context "golang.org/x/net/context"

type htmlMyTest struct {
	client   MyTestClient
	stringer func(interface{}) ([]byte, error)
	port     string
}

func NewHTMLMyTestServer(client MyTestClient, stringer func(interface{}) ([]byte, error)) *htmlMyTest {
	if stringer == nil {
		stringer = encoding_json.Marshal
	}
	return &htmlMyTest{client, stringer, ":8080"}
}
func (this *htmlMyTest) Serve(addr string) error {
	net_http.HandleFunc("/MyTest/UnaryCall", this.UnaryCall)
	net_http.HandleFunc("/MyTest/Downstream", this.Downstream)
	net_http.HandleFunc("/MyTest/Upstream", this.Upstream)
	net_http.HandleFunc("/MyTest/Bidi", this.Bidi)
	_, port, err := net.SplitHostPort(addr)
	if err != nil {
		return err
	}
	this.port = port
	return net_http.ListenAndServe(addr, nil)
}
func (this *htmlMyTest) UnaryCall(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - UnaryCall</title>"))
	w.Write([]byte("</head>"))
	jsonString := req.FormValue("json")
	if len(jsonString) == 0 {
		s := "<form action=\"/MyTest/UnaryCall\" method=\"GET\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyRequest):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	msg := &MyRequest{}
	err := encoding_json.Unmarshal([]byte(jsonString), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := this.client.UnaryCall(golang_org_x_net_context.Background(), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Downstream(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Downstream</title>"))
	w.Write([]byte("</head>"))
	jsonString := req.FormValue("json")
	if len(jsonString) == 0 {
		s := "<form action=\"/MyTest/Downstream\" method=\"GET\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyRequest):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	msg := &MyRequest{}
	err := encoding_json.Unmarshal([]byte(jsonString), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	down, err := this.client.Downstream(golang_org_x_net_context.Background(), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	for {
		reply, err := down.Recv()
		if err != nil {
			if err == io.EOF {
				return
			}
			w.Write([]byte(err.Error()))
			return
		}
		out, err := this.stringer(reply)
		if err != nil {
			if err == io.EOF {
				return
			}
			w.Write([]byte(err.Error()))
			return
		}
		w.Write(out)
	}
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Upstream(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Upstream</title>"))
	w.Write([]byte("</head>"))
	jsonString := req.FormValue("json")
	if len(jsonString) == 0 {
		s := "<form action=\"/MyTest/Upstream\" method=\"GET\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyMsg):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	msg := &MyMsg{}
	err := encoding_json.Unmarshal([]byte(jsonString), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	up, err := this.client.Upstream(golang_org_x_net_context.Background())
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	err = up.Send(msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := up.CloseAndRecv()
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Bidi(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Bidi</title>"))
	w.Write([]byte("</head>"))
	jsonString := req.FormValue("json")
	if len(jsonString) == 0 {
		s := "<form action=\"/MyTest/Bidi\" method=\"GET\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyMsg):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	msg := &MyMsg{}
	err := encoding_json.Unmarshal([]byte(jsonString), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	bidi, err := this.client.Bidi(golang_org_x_net_context.Background())
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	err = bidi.Send(msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := bidi.Recv()
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}
