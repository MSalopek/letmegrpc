// Code generated by protoc-gen-gogo.
// source: grpc.proto
// DO NOT EDIT!

/*
Package grpc is a generated protocol buffer package.

It is generated from these files:
	grpc.proto

It has these top-level messages:
	MyRequest
	MyResponse
	MyMsg
	MyMsg2
*/
package grpc

import net_http "net/http"
import io_ioutil "io/ioutil"
import encoding_json "encoding/json"
import io "io"
import net "net"
import golang_org_x_net_context "golang.org/x/net/context"

type htmlMyTest struct {
	client   MyTestClient
	stringer func(interface{}) ([]byte, error)
	prefix   string
	port     string
}

func NewHTMLMyTestServer(prefix string, client MyTestClient, stringer func(interface{}) ([]byte, error)) *htmlMyTest {
	if stringer == nil {
		stringer = encoding_json.Marshal
	}
	return &htmlMyTest{client, stringer, prefix, ":8080"}
}
func (this *htmlMyTest) Serve(addr string) error {
	net_http.HandleFunc(this.prefix+"/UnaryCall", this.UnaryCall)
	net_http.HandleFunc(this.prefix+"/Downstream", this.Downstream)
	net_http.HandleFunc(this.prefix+"/Upstream", this.Upstream)
	net_http.HandleFunc(this.prefix+"/Bidi", this.Bidi)
	_, port, err := net.SplitHostPort(addr)
	if err != nil {
		return err
	}
	this.port = port
	return net_http.ListenAndServe(addr, nil)
}
func (this *htmlMyTest) UnaryCall(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - UnaryCall</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/UnaryCall:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyRequest):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyRequest{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := this.client.UnaryCall(golang_org_x_net_context.Background(), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Downstream(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Downstream</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/Downstream:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyRequest):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyRequest{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	down, err := this.client.Downstream(golang_org_x_net_context.Background(), msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	for {
		reply, err := down.Recv()
		if err != nil {
			if err == io.EOF {
				return
			}
			w.Write([]byte(err.Error()))
			return
		}
		out, err := this.stringer(reply)
		if err != nil {
			if err == io.EOF {
				return
			}
			w.Write([]byte(err.Error()))
			return
		}
		w.Write(out)
	}
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Upstream(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Upstream</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/Upstream:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyMsg):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyMsg{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	up, err := this.client.Upstream(golang_org_x_net_context.Background())
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	err = up.Send(msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := up.CloseAndRecv()
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}
func (this *htmlMyTest) Bidi(w net_http.ResponseWriter, req *net_http.Request) {
	w.Write([]byte("<html>"))
	w.Write([]byte("<head>"))
	w.Write([]byte("<title>MyTest - Bidi</title>"))
	w.Write([]byte("<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js\"></script>"))
	w.Write([]byte("</head>"))
	if req.Method == "GET" {
		s := "<form action=\"" + this.prefix + "/Bidi:" + this.port + " method=\"POST\">"
		w.Write([]byte(s))
		w.Write([]byte("Json for MyTest(.grpc.MyMsg):<br>"))
		w.Write([]byte("<input name=\"json\" type=\"text\"><br>"))
		w.Write([]byte("<input type=\"submit\" value=\"Submit\"/>"))
		w.Write([]byte("</form>"))
		w.Write([]byte("</html>"))
		return
	}
	//assuming it is a POST which contains json
	data, err := io_ioutil.ReadAll(req.Body)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	msg := &MyMsg{}
	err = encoding_json.Unmarshal(data, msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	bidi, err := this.client.Bidi(golang_org_x_net_context.Background())
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	err = bidi.Send(msg)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	reply, err := bidi.Recv()
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	out, err := this.stringer(reply)
	if err != nil {
		if err == io.EOF {
			return
		}
		w.Write([]byte(err.Error()))
		return
	}
	w.Write(out)
	w.Write([]byte("</html>"))
}
