// Code generated by protoc-gen-gogo.
// source: proto2.proto
// DO NOT EDIT!

/*
Package proto2 is a generated protocol buffer package.

It is generated from these files:
	proto2.proto

It has these top-level messages:
	Artist
	Song
	Album
*/
package proto2

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Instrument int32

const (
	Instrument_Voice  Instrument = 0
	Instrument_Guitar Instrument = 1
	Instrument_Drum   Instrument = 2
)

var Instrument_name = map[int32]string{
	0: "Voice",
	1: "Guitar",
	2: "Drum",
}
var Instrument_value = map[string]int32{
	"Voice":  0,
	"Guitar": 1,
	"Drum":   2,
}

func (x Instrument) Enum() *Instrument {
	p := new(Instrument)
	*p = x
	return p
}
func (x Instrument) String() string {
	return proto.EnumName(Instrument_name, int32(x))
}
func (x *Instrument) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Instrument_value, data, "Instrument")
	if err != nil {
		return err
	}
	*x = Instrument(value)
	return nil
}
func (Instrument) EnumDescriptor() ([]byte, []int) { return fileDescriptorProto2, []int{0} }

type Genre int32

const (
	Genre_Pop          Genre = 0
	Genre_Rock         Genre = 1
	Genre_Jazz         Genre = 2
	Genre_NintendoCore Genre = 3
	Genre_Indie        Genre = 4
	Genre_Punk         Genre = 5
	Genre_Dance        Genre = 6
)

var Genre_name = map[int32]string{
	0: "Pop",
	1: "Rock",
	2: "Jazz",
	3: "NintendoCore",
	4: "Indie",
	5: "Punk",
	6: "Dance",
}
var Genre_value = map[string]int32{
	"Pop":          0,
	"Rock":         1,
	"Jazz":         2,
	"NintendoCore": 3,
	"Indie":        4,
	"Punk":         5,
	"Dance":        6,
}

func (x Genre) Enum() *Genre {
	p := new(Genre)
	*p = x
	return p
}
func (x Genre) String() string {
	return proto.EnumName(Genre_name, int32(x))
}
func (x *Genre) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Genre_value, data, "Genre")
	if err != nil {
		return err
	}
	*x = Genre(value)
	return nil
}
func (Genre) EnumDescriptor() ([]byte, []int) { return fileDescriptorProto2, []int{1} }

type Artist struct {
	Name             *string     `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
	Role             *Instrument `protobuf:"varint,2,opt,name=Role,json=role,enum=proto2.Instrument,def=1" json:"Role,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *Artist) Reset()                    { *m = Artist{} }
func (m *Artist) String() string            { return proto.CompactTextString(m) }
func (*Artist) ProtoMessage()               {}
func (*Artist) Descriptor() ([]byte, []int) { return fileDescriptorProto2, []int{0} }

const Default_Artist_Role Instrument = Instrument_Guitar

func (m *Artist) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Artist) GetRole() Instrument {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_Artist_Role
}

type Song struct {
	Name             *string   `protobuf:"bytes,1,opt,name=Name,json=name,def=Type in a Name" json:"Name,omitempty"`
	Track            *uint64   `protobuf:"varint,2,opt,name=Track,json=track,def=1" json:"Track,omitempty"`
	Duration         *float64  `protobuf:"fixed64,3,opt,name=Duration,json=duration,def=3.3" json:"Duration,omitempty"`
	Composer         []*Artist `protobuf:"bytes,4,rep,name=Composer,json=composer" json:"Composer,omitempty"`
	Good             *bool     `protobuf:"varint,5,opt,name=Good,json=good,def=1" json:"Good,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Song) Reset()                    { *m = Song{} }
func (m *Song) String() string            { return proto.CompactTextString(m) }
func (*Song) ProtoMessage()               {}
func (*Song) Descriptor() ([]byte, []int) { return fileDescriptorProto2, []int{1} }

const Default_Song_Name string = "Type in a Name"
const Default_Song_Track uint64 = 1
const Default_Song_Duration float64 = 3.3
const Default_Song_Good bool = true

func (m *Song) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return Default_Song_Name
}

func (m *Song) GetTrack() uint64 {
	if m != nil && m.Track != nil {
		return *m.Track
	}
	return Default_Song_Track
}

func (m *Song) GetDuration() float64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return Default_Song_Duration
}

func (m *Song) GetComposer() []*Artist {
	if m != nil {
		return m.Composer
	}
	return nil
}

func (m *Song) GetGood() bool {
	if m != nil && m.Good != nil {
		return *m.Good
	}
	return Default_Song_Good
}

type Album struct {
	Name             *string   `protobuf:"bytes,1,opt,name=Name,json=name" json:"Name,omitempty"`
	Song             []*Song   `protobuf:"bytes,2,rep,name=Song,json=song" json:"Song,omitempty"`
	Genre            *Genre    `protobuf:"varint,3,opt,name=Genre,json=genre,enum=proto2.Genre,def=1" json:"Genre,omitempty"`
	Year             *string   `protobuf:"bytes,4,opt,name=Year,json=year,def=2015" json:"Year,omitempty"`
	Producer         []string  `protobuf:"bytes,5,rep,name=Producer,json=producer" json:"Producer,omitempty"`
	Mediocre         *bool     `protobuf:"varint,6,opt,name=Mediocre,json=mediocre,def=1" json:"Mediocre,omitempty"`
	Rated            *bool     `protobuf:"varint,7,opt,name=Rated,json=rated" json:"Rated,omitempty"`
	Epilogue         *string   `protobuf:"bytes,8,opt,name=Epilogue,json=epilogue" json:"Epilogue,omitempty"`
	Likes            []bool    `protobuf:"varint,9,rep,name=Likes,json=likes" json:"Likes,omitempty"`
	Stars            *int64    `protobuf:"varint,10,opt,name=Stars,json=stars" json:"Stars,omitempty"`
	Serial           []float64 `protobuf:"fixed64,11,rep,name=Serial,json=serial" json:"Serial,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Album) Reset()                    { *m = Album{} }
func (m *Album) String() string            { return proto.CompactTextString(m) }
func (*Album) ProtoMessage()               {}
func (*Album) Descriptor() ([]byte, []int) { return fileDescriptorProto2, []int{2} }

const Default_Album_Genre Genre = Genre_Rock
const Default_Album_Year string = "2015"
const Default_Album_Mediocre bool = true

func (m *Album) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Album) GetSong() []*Song {
	if m != nil {
		return m.Song
	}
	return nil
}

func (m *Album) GetGenre() Genre {
	if m != nil && m.Genre != nil {
		return *m.Genre
	}
	return Default_Album_Genre
}

func (m *Album) GetYear() string {
	if m != nil && m.Year != nil {
		return *m.Year
	}
	return Default_Album_Year
}

func (m *Album) GetProducer() []string {
	if m != nil {
		return m.Producer
	}
	return nil
}

func (m *Album) GetMediocre() bool {
	if m != nil && m.Mediocre != nil {
		return *m.Mediocre
	}
	return Default_Album_Mediocre
}

func (m *Album) GetRated() bool {
	if m != nil && m.Rated != nil {
		return *m.Rated
	}
	return false
}

func (m *Album) GetEpilogue() string {
	if m != nil && m.Epilogue != nil {
		return *m.Epilogue
	}
	return ""
}

func (m *Album) GetLikes() []bool {
	if m != nil {
		return m.Likes
	}
	return nil
}

func (m *Album) GetStars() int64 {
	if m != nil && m.Stars != nil {
		return *m.Stars
	}
	return 0
}

func (m *Album) GetSerial() []float64 {
	if m != nil {
		return m.Serial
	}
	return nil
}

func init() {
	proto.RegisterType((*Artist)(nil), "proto2.Artist")
	proto.RegisterType((*Song)(nil), "proto2.Song")
	proto.RegisterType((*Album)(nil), "proto2.Album")
	proto.RegisterEnum("proto2.Instrument", Instrument_name, Instrument_value)
	proto.RegisterEnum("proto2.Genre", Genre_name, Genre_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for Proto2 service

type Proto2Client interface {
	Produce(ctx context.Context, in *Album, opts ...grpc.CallOption) (*Album, error)
}

type proto2Client struct {
	cc *grpc.ClientConn
}

func NewProto2Client(cc *grpc.ClientConn) Proto2Client {
	return &proto2Client{cc}
}

func (c *proto2Client) Produce(ctx context.Context, in *Album, opts ...grpc.CallOption) (*Album, error) {
	out := new(Album)
	err := grpc.Invoke(ctx, "/proto2.Proto2/Produce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Proto2 service

type Proto2Server interface {
	Produce(context.Context, *Album) (*Album, error)
}

func RegisterProto2Server(s *grpc.Server, srv Proto2Server) {
	s.RegisterService(&_Proto2_serviceDesc, srv)
}

func _Proto2_Produce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Album)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proto2Server).Produce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto2.Proto2/Produce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proto2Server).Produce(ctx, req.(*Album))
	}
	return interceptor(ctx, in, info, handler)
}

var _Proto2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto2.Proto2",
	HandlerType: (*Proto2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Produce",
			Handler:    _Proto2_Produce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorProto2,
}

func init() { proto.RegisterFile("proto2.proto", fileDescriptorProto2) }

var fileDescriptorProto2 = []byte{
	// 505 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x92, 0xc1, 0x6a, 0xdc, 0x30,
	0x10, 0x86, 0xe3, 0xb5, 0xe4, 0x68, 0x27, 0xe9, 0x62, 0x44, 0x69, 0x45, 0x2e, 0x15, 0x7b, 0xa9,
	0x1b, 0xe8, 0xd2, 0x38, 0xf4, 0xe2, 0x5b, 0x48, 0x4a, 0x48, 0x49, 0xc3, 0xa2, 0x84, 0x40, 0x8f,
	0xaa, 0x3d, 0x2c, 0x66, 0x6d, 0xc9, 0xc8, 0xf2, 0x21, 0x79, 0xa4, 0x3e, 0x40, 0x9f, 0xaf, 0xc8,
	0xeb, 0x6d, 0x53, 0xe8, 0x49, 0x7c, 0xff, 0x8c, 0x7e, 0x66, 0x7e, 0x09, 0x8e, 0x3b, 0x67, 0xbd,
	0xcd, 0x57, 0xe3, 0xc1, 0x93, 0x1d, 0x2d, 0x6f, 0x21, 0xb9, 0x70, 0xbe, 0xee, 0x3d, 0xe7, 0x40,
	0xee, 0x74, 0x8b, 0x22, 0x92, 0x51, 0x36, 0x57, 0xc4, 0xe8, 0x16, 0xf9, 0x0a, 0x88, 0xb2, 0x0d,
	0x8a, 0x99, 0x8c, 0xb2, 0x45, 0xce, 0x57, 0x93, 0xc5, 0x8d, 0xe9, 0xbd, 0x1b, 0x5a, 0x34, 0xbe,
	0x48, 0xae, 0x87, 0xda, 0x6b, 0xa7, 0x88, 0xb3, 0x0d, 0x2e, 0x7f, 0x46, 0x40, 0xee, 0xad, 0xd9,
	0xf0, 0xe5, 0x4b, 0xb3, 0x62, 0xf1, 0xf0, 0xd4, 0xa1, 0xac, 0x8d, 0xd4, 0x32, 0xa8, 0x93, 0xf9,
	0x5b, 0xa0, 0x0f, 0x4e, 0x97, 0xdb, 0xd1, 0x9d, 0x14, 0xd1, 0x99, 0xa2, 0x3e, 0x30, 0x7f, 0x07,
	0xec, 0x6a, 0x70, 0xda, 0xd7, 0xd6, 0x88, 0x58, 0x46, 0x59, 0x54, 0xc4, 0xe7, 0xab, 0x73, 0xc5,
	0xaa, 0x49, 0xe4, 0xa7, 0xc0, 0x2e, 0x6d, 0xdb, 0xd9, 0x1e, 0x9d, 0x20, 0x32, 0xce, 0x8e, 0xf2,
	0xc5, 0x7e, 0xb4, 0xdd, 0x32, 0x8a, 0x95, 0x53, 0x9d, 0x0b, 0x20, 0xd7, 0xd6, 0x56, 0x82, 0xca,
	0x28, 0x63, 0x05, 0xf1, 0x6e, 0x40, 0x45, 0x36, 0xd6, 0x56, 0xcb, 0x5f, 0x33, 0xa0, 0x17, 0xcd,
	0x8f, 0xa1, 0xfd, 0xef, 0xea, 0x72, 0xb7, 0x89, 0x98, 0x8d, 0xfe, 0xc7, 0x7b, 0xff, 0xa0, 0x29,
	0xd2, 0x87, 0x1d, 0x3f, 0x00, 0xbd, 0x46, 0xe3, 0x70, 0x9c, 0x71, 0x91, 0xbf, 0xda, 0xb7, 0x8c,
	0x62, 0x41, 0x94, 0x2d, 0xb7, 0x8a, 0x6e, 0x02, 0x84, 0x21, 0xbe, 0xa3, 0x0e, 0xc3, 0x86, 0x38,
	0x48, 0xfe, 0xe9, 0xec, 0xb3, 0x22, 0x4f, 0xa8, 0x1d, 0x3f, 0x01, 0xb6, 0x76, 0xb6, 0x1a, 0x4a,
	0x74, 0x82, 0xca, 0x38, 0x9b, 0x2b, 0xd6, 0x4d, 0xcc, 0x25, 0xb0, 0x6f, 0x58, 0xd5, 0xb6, 0x74,
	0x28, 0x92, 0x17, 0xe3, 0xb3, 0x76, 0x52, 0xf9, 0x6b, 0xa0, 0x4a, 0x7b, 0xac, 0xc4, 0x61, 0x28,
	0x2b, 0xea, 0x02, 0x04, 0xcf, 0x2f, 0x5d, 0xdd, 0xd8, 0xcd, 0x80, 0x82, 0x8d, 0x2b, 0x31, 0x9c,
	0x38, 0xdc, 0xb8, 0xad, 0xb7, 0xd8, 0x8b, 0xb9, 0x8c, 0xc3, 0x8d, 0x26, 0x40, 0x50, 0xef, 0xbd,
	0x76, 0xbd, 0x00, 0x19, 0x65, 0xb1, 0xa2, 0x7d, 0x00, 0xfe, 0x06, 0x92, 0x7b, 0x74, 0xb5, 0x6e,
	0xc4, 0x91, 0x8c, 0xb3, 0x48, 0x25, 0xfd, 0x48, 0xa7, 0x1f, 0x01, 0xfe, 0xfe, 0x00, 0x3e, 0x07,
	0xfa, 0x68, 0xeb, 0x12, 0xd3, 0x03, 0x0e, 0x30, 0x7d, 0x87, 0x34, 0xe2, 0x0c, 0xc8, 0x95, 0x1b,
	0xda, 0x74, 0x76, 0xfa, 0x38, 0xe5, 0xc4, 0x0f, 0x21, 0x5e, 0xdb, 0x2e, 0x3d, 0x08, 0xb5, 0x90,
	0xce, 0xae, 0xeb, 0xab, 0x7e, 0x7e, 0x4e, 0x67, 0x3c, 0x85, 0xe3, 0xbb, 0xda, 0x78, 0x34, 0x95,
	0xbd, 0xb4, 0x0e, 0xd3, 0x38, 0x18, 0xdf, 0x98, 0xaa, 0xc6, 0x94, 0x84, 0xb6, 0xf5, 0x60, 0xb6,
	0x29, 0x0d, 0xe2, 0x95, 0x36, 0x25, 0xa6, 0x49, 0x7e, 0x06, 0xc9, 0x7a, 0x4c, 0x9c, 0xbf, 0x87,
	0xc3, 0x29, 0x44, 0xfe, 0xe7, 0x15, 0xc6, 0x97, 0x3d, 0xf9, 0x17, 0x7f, 0x07, 0x00, 0x00, 0xff,
	0xff, 0x3b, 0x22, 0x00, 0xe2, 0x04, 0x03, 0x00, 0x00,
}
